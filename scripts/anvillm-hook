#!/usr/bin/env bash
set -euo pipefail

# Support two modes:
# 1. JSON on stdin (for wrapper scripts)
# 2. Event name as first argument (for direct invocation)

if [[ $# -gt 0 ]]; then
    # Direct invocation: event name passed as argument
    event="$1"
    cwd="${2:-$PWD}"
else
    # JSON mode: parse from stdin
    TIMEOUT=$(command -v gtimeout 2>/dev/null || command -v timeout 2>/dev/null || :)
    payload=$(${TIMEOUT:+"$TIMEOUT" 3} jq -c . 2>/dev/null || :)
    [[ $payload ]] || exit 0
    
    event=''
    cwd=$PWD
    IFS=$'\t' read -r _event _cwd < <(jq -r '"\(.hook_event_name // "")\t\(.cwd // "")"' <<<"$payload") || :
    [[ ${_event:-} ]] && event=$_event
    [[ ${_cwd:-} ]] && cwd=$_cwd
fi

# Helper for anvillm state transitions
anvillm_set_state() {
    local agent_id=${AGENT_ID:-}
    [[ $agent_id ]] && echo "$1" | 9p write "agent/$agent_id/state" 2>/dev/null || true
}

case "$event" in
    agentSpawn)
        cd "$cwd" 2>/dev/null || :
        if command -v agent-prompt &>/dev/null; then
            agent-prompt --harness=kiro
        else
            skills_cmd=$(command -v agent-skills 2>/dev/null || echo anvillm-skills)
            sed "s/anvillm-skills/$skills_cmd/g" ~/.kiro/SKILLS_PROMPT.md
        fi
        ;;
    userPromptSubmit)
        anvillm_set_state running
        ;;
    preToolUse)
        ;;
    postToolUse)
        ;;
    stop)
        anvillm_set_state idle
        ;;
    *)
        ;;
esac
